# 二叉树

## 原理

1. 无根节点, 则生成二叉树根节点
2. 当前节点值小于父节点值, 则迁移到左子树中, 如果左子树为空, 则占用为节点位, 否则继续遍历寻找占位
3. 当前节点值大于父节点值, 则迁移到右子树中, 如果右子树为空, 则占用为节点位, 否则继续遍历寻找占位

如图所示二叉树:

<mermaid>
graph TD
  A-->B
    A-->C
    B-->D
    B-->E
    C-->F
</mermaid>

> 前序遍历

- 遍历规则

1. 访问根节点
2. 前序遍历左子树
3. 前序遍历右子树

- 前序遍历最高效的复制出整个二叉树

输出结果: ABDECF

> 中序遍历

- 遍历规则

1. 中序遍历左子树
2. 访问根节点
3. 中序遍历右子树

- 中序遍历可使用于数组排序

输出结果: DBEAFC

> 后序遍历

- 遍历规则

1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根节点

- 后序遍历可使用于系统查找文件

输出结果: DEBCFA

> 寻找最小值

1. 以根节点为起点, 一直以二叉树最左边节点寻找

输出结果: ABD (D 为最小值)

> 寻找最大值

1. 以根节点为起点, 一直以二叉树最右边节点寻找

输出结果: ACF (F 为最大值)

> 寻找节点

1. 以根节点为起点, 当前要检索的值小于当前节点值, 则进入左子树, 反之进入右子树

> 删除节点

1. 先寻找要删除节点的位置,
2. 如果节点没有左右节点 (如删除 F 节点), 则将该节点直接删除并返回
3. 如果节点有左节点, 无右节点, (如删除 C 节点, 假设 F 为左节点), 则左节点替代要被删除的节点, 结果如下图

<mermaid>
graph TD
    A-->B
    A-->F
    B-->D
    B-->E
</mermaid>

4. 如果节点有左节点, 无右节点, (如删除 C 节点, 假设 F 为左节点), 则左节点替代要被删除的节点
5. 如果节点左右节点都存在, (如删除 B 节点), 先寻找出右子树下最小节点, 将最小节点替代要被删除的节点, 并将右子树的最小节点删除, 结果如下图

<mermaid>
graph TD
    A-->E
    A-->C
    E-->D
    C-->F
</mermaid>

## 代码演示

<<< @/modules/算法/二叉树/01.js
